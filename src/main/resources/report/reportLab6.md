# Lab Report: Parser & Building an Abstract Syntax Tree

### Course: Formal Languages & Finite Automata
### Author: Costov Maxim

---

## Overview
Parsing is the process of analyzing a sequence of tokens to determine their grammatical structure with respect to a given formal grammar. This lab focuses on implementing a parser that constructs an Abstract Syntax Tree (AST) from tokens generated by a lexer. The AST is a hierarchical representation of the syntactic structure of the input text, which is essential for further stages of compilation or interpretation.

---

## Objectives
1. **Understand parsing**: Learn how tokens are transformed into a structured representation (AST).
2. **Implement a parser**: Create a recursive-descent parser for a simple grammar.
3. **Build an AST**: Design data structures to represent the AST and visualize it.

---

## Theoretical Background
**Parsing**:
- Converts a flat sequence of tokens into a nested structure (parse tree or AST).
- Uses grammar rules to validate syntax and organize tokens hierarchically.

**Abstract Syntax Tree (AST)**:
- A simplified parse tree that omits unnecessary details (e.g., parentheses, semicolons).
- Nodes represent language constructs (e.g., expressions, statements).

**Recursive-Descent Parsing**:
- A top-down parsing technique where each grammar rule corresponds to a function.
- Uses lookahead tokens to decide which production rule to apply.

**Grammar Rules (for the implemented parser)**:
```
expression → equality  
equality → comparison ( ( "!=" | "==" ) comparison )*  
comparison → term ( ( ">" | ">=" | "<" | "<=" ) term )*  
term → factor ( ( "-" | "+" ) factor )*  
factor → unary ( ( "/" | "*" ) unary )*  
unary → ( "!" | "-" ) unary | primary  
primary → NUMBER | STRING | "true" | "false" | "nil" | "(" expression ")"
```

---

## Implementation
The parser is implemented in Java, consisting of three main classes: `Parser`, `Expr` (AST nodes), and `AstPrinter`.

### Key Components:
1. **Parser Class**:
    - **Recursive-Descent Methods**: Each grammar rule has a corresponding method (e.g., `equality()`, `comparison()`).
    - **Error Handling**: Throws `ParseError` on syntax violations (e.g., missing closing parenthesis).
    - **Token Consumption**: Uses `match()` and `consume()` to process tokens.

   ```java
   private Expr equality() {
       Expr expr = comparison();
       while (match(BANG_EQUAL, EQUAL_EQUAL)) {
           Token operator = previous();
           Expr right = comparison();
           expr = new Expr.Binary(expr, operator, right);
       }
       return expr;
   }
   ```

2. **AST Nodes (`Expr` Class)**:
    - **Binary Expressions**: Represents operations like `1 + 2` or `x >= 5`.
    - **Unary Expressions**: Represents operations like `-x` or `!true`.
    - **Literals**: Holds values like numbers, strings, booleans, and `nil`.
    - **Grouping**: Manages parenthesized expressions.

   ```java
   static class Binary extends Expr {
       Binary(Expr left, Token operator, Expr right) {
           this.left = left;
           this.operator = operator;
           this.right = right;
       }
       // ... (accept method for visitor pattern)
   }
   ```

3. **AST Printer (`AstPrinter` Class)**:
    - **Visitor Pattern**: Traverses the AST and generates a string representation.
    - **Parenthesized Output**: Formats expressions like Lisp (e.g., `(+ 1 2)`).

   ```java
   public String visitBinaryExpr(Expr.Binary expr) {
       return parenthesize(expr.operator.lexeme, expr.left, expr.right);
   }
   ```

---

## Results
The parser successfully constructs an AST from valid input. Below are example outputs:

### Input 1:
```java
1 + 2 * 3
```  
### AST Output 1:
```lisp
(+ 1.0 (* 2.0 3.0))
```  

### Input 2:
```java
!(5 == 3)
```  
### AST Output 2:
```lisp
(! (group (== 5.0 3.0)))
```  

### Input 3:
```java
"hello" + "world"
```  
### AST Output 3:
```lisp
(+ "hello" "world")
```  

---

## Conclusion
This lab involved:
1. Implementing a **recursive-descent parser** for arithmetic/logical expressions.
2. Designing **AST data structures** to represent parsed expressions.
3. Visualizing the AST using a **printer**.

Challenges included handling operator precedence (e.g., `*` before `+`) and error recovery. Future improvements could extend the grammar to support variables, functions, and control flow.

---

## References
1. [Crafting Interpreters - Parsing](https://craftinginterpreters.com/parsing-expressions.html)
2. [Abstract Syntax Tree - Wikipedia](https://en.wikipedia.org/wiki/Abstract_syntax_tree)

---

## Repository Link
[GitHub Repository](https://github.com/MaxKostov/dsl/tree/main/src/main/resources/report)
